/**
 *
 * @file z_rradd_tests.c
 *
 * Tests and validate the core_zrradd() routine.
 *
 * @copyright 2015-2018 Bordeaux INP, CNRS (LaBRI UMR 5800), Inria,
 *                      Univ. Bordeaux. All rights reserved.
 *
 * @version 6.0.1
 * @author Gregoire Pichon
 * @date 2018-07-16
 *
 * @precisions normal z -> c d s
 *
 **/
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <pastix.h>
#include "common/common.h"
#include <lapacke.h>
#include <cblas.h>
#include "blend/solver.h"
#include "kernels/pastix_zcores.h"
#include "kernels/pastix_zlrcores.h"
#include "z_tests.h"

#define PRINT_RES(_ret_)                        \
    if(_ret_ == -1) {                           \
        printf("UNDEFINED\n");                  \
    }                                           \
    else if(_ret_ > 0) {                        \
        printf("FAILED(%d)\n", _ret_);          \
        err++;                                  \
    }                                           \
    else {                                      \
        printf("SUCCESS\n");                    \
    }

int
z_rradd_test( int mode, double tolerance,
              pastix_int_t offx, pastix_int_t offy,
              pastix_int_t ma, pastix_int_t na, pastix_int_t ra, pastix_int_t lda,
              pastix_int_t mb, pastix_int_t nb, pastix_int_t rb, pastix_int_t ldb )
{
    fct_ge2lr_t core_ge2lr = ge2lrMethods[PastixCompressMethodPQRCP][PastixComplex64-2];
    pastix_complex64_t *A = malloc( na * lda * sizeof(pastix_complex64_t) );
    pastix_complex64_t *B = malloc( nb * ldb * sizeof(pastix_complex64_t) );
    pastix_complex64_t *C = malloc( nb * ldb * sizeof(pastix_complex64_t) );
    pastix_lrblock_t lrA, lrB;
    double normA, normB, normC;
    int i, ret, rc = 0;

    /*
     * Lets' generate the test matrices:
     *   1) Generate a matrix of a given rank in dense
     *   2) Compress them with any of the compression kernels (Here PQRCP)
     *   3) Uncompress them to check only the loss generated by the rradd kernel
     */
    z_lowrank_genmat( mode, tolerance, ra,
                      ma, na, A, lda, &normA );
    core_ge2lr( tolerance, pastix_imin( ma, na ),
                ma, na, A, lda, &lrA );
    core_zlr2ge( PastixNoTrans, ma, na,
                 &lrA, A, lda );

    z_lowrank_genmat( mode, tolerance, rb,
                      mb, nb, B, ldb, &normB );
    core_ge2lr( tolerance, pastix_imin( mb, nb ),
                mb, nb, B, ldb, &lrB );
    core_zlr2ge( PastixNoTrans, mb, nb,
                 &lrB, B, ldb );

    /* Perform C = B - A in full rank format */
    LAPACKE_zlacpy_work(LAPACK_COL_MAJOR, 'A', mb, nb,
                        B, ldb, C, ldb );
    core_zgeadd( PastixNoTrans, ma, na,
                 -1.0, A,                     lda,
                  1.0, C + offx + ldb * offy, ldb );

    normC = LAPACKE_zlange_work( LAPACK_COL_MAJOR, 'f', mb, nb,
                                 C, ldb, NULL );

    fprintf( stdout, "%7s %4s %12s %12s %12s %12s\n",
             "Method", "Rank", "Time", "||B-A||_f", "||c(c(B)-c(A))-(B-A)||_f",
             "||c(B-A)-(B-A)||_f/(||B-A||_f * eps)" );

    /* Let's test all methods we have */
    for(i=0; i<PastixCompressMethodNbr; i++)
    {
        ret = z_lowrank_check_rradd( i, tolerance,
                                     offx, offy,
                                     ma, na, &lrA,
                                     mb, nb, &lrB,
                                     C, ldb, normC,
                                     rraddMethods[i][PastixComplex64-2]);
        rc += ret * (1 << i);
    }

    core_zlrfree( &lrA );
    core_zlrfree( &lrB );
    free(A);
    free(B);
    free(C);
    return rc;
}

int main (int argc, char **argv)
{
    (void) argc;
    (void) argv;
    int err = 0;
    int ret;
    pastix_int_t m, r, rmax;
    double       eps = LAPACKE_dlamch_work('e');
    double       tolerance = sqrt(eps);

    for (m=100; m<400; m = 2*m) {
        rmax = core_get_rklimit( m, m );

        for (r=0; (r + (r/2)) < rmax; r += ( r + 1 ) ) {
            pastix_int_t mB    = m;
            pastix_int_t mA    = m / 2;
            pastix_int_t rankA = r/2;
            pastix_int_t rankB = r;
            pastix_int_t offx  = m / 4;
            pastix_int_t offy  = m / 8;

            printf( "  -- Test RRADD MA=NA=LDA=%ld MB=NB=LDB=%ld RA=%ld RB=%ld rkmax=%ld\n",
                    (long)mA, (long)mB, (long)rankA, (long)rankB,
                    (long)core_get_rklimit( mB, mB ) );

            ret = z_rradd_test( 0, tolerance, offx, offy,
                                mA, mA, rankA, mA,
                                mB, mB, rankB, mB );
            PRINT_RES(ret);
        }
    }

    if( err == 0 ) {
        printf(" -- All tests PASSED --\n");
        return EXIT_SUCCESS;
    }
    else
    {
        printf(" -- %d tests FAILED --\n", err);
        return EXIT_FAILURE;
    }
}
